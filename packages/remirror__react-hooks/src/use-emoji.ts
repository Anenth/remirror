import { Dispatch, SetStateAction, useCallback, useMemo, useState } from 'react';
import { ExtensionPriority, isEmptyArray, isUndefined } from '@remirror/core';
import {
  EmojiExtension,
  EmojiSuggestHandler,
  EmojiSuggestHandlerCommand,
  EmojiSuggestHandlerProps,
  FlatEmoji,
} from '@remirror/extension-emoji';
import { useExtension, useHelpers } from '@remirror/react';

import { indexFromArrowPress } from './react-hook-utils';
import { useKeymap } from './use-keymap';

export interface FlatEmojiWithUrl extends FlatEmoji {
  /**
   * The svg url for CDN access.
   */
  url: string;
}

export interface EmojiState extends Pick<EmojiSuggestHandlerProps, 'range'> {
  /**
   * The list of emoji generated by the query.
   *
   * @default []
   */
  list: FlatEmojiWithUrl[];

  /**
   * The index of the currently matched emoji.
   *
   * @default 0
   */
  index: number;

  /**
   * The command to run to replace the query with the request emoji.
   *
   * @default undefined
   */
  apply: EmojiSuggestHandlerCommand;
}

/**
 * A hook for managing changes in the emoji suggestions.
 */
function useEmojiChangeHandler(setState: SetEmojiState) {
  const onChange: EmojiSuggestHandler = useCallback(
    (props) => {
      const { change, exit, query, moji, apply, range } = props;

      if (change) {
        setState({
          list: moji.search(query).map((emoji) => ({ ...emoji, url: moji.url(emoji) })),
          index: 0,
          apply: (code) => {
            setState(null);
            return apply(code);
          },
          range,
        });
      }

      if (exit) {
        setState(null);
      }
    },
    [setState],
  );

  useExtension(EmojiExtension, ({ addHandler }) => addHandler('suggestEmoji', onChange), [
    onChange,
  ]);
}

/**
 * A hook for adding keybindings to the emoji dropdown.
 */
function useEmojiKeyBindings(setState: SetEmojiState, state: EmojiState | null) {
  const helpers = useHelpers();

  /**
   * Create the arrow bindings for the emoji suggesters.
   */
  const createArrowBinding = useCallback(
    (key: 'up' | 'down') => () => {
      if (!state || isEmptyArray(state.list)) {
        return false;
      }

      const { list, index } = state;
      const direction = key === 'up' ? 'previous' : 'next';
      const activeIndex = indexFromArrowPress({
        direction,
        matchLength: list.length,
        previousIndex: index,
      });

      setState({ ...state, index: activeIndex });

      return true;
    },
    [state, setState],
  );

  const ArrowUp = useMemo(() => createArrowBinding('up'), [createArrowBinding]);
  const ArrowDown = useMemo(() => createArrowBinding('down'), [createArrowBinding]);

  const bindings = useMemo(
    () => ({
      /**
       * Handle the enter key being pressed
       */
      Enter: () => {
        if (!state || isEmptyArray(state.list)) {
          return false;
        }

        const { list, index } = state;

        const emoji = list[index];

        // Check if a matching id exists because the user has selected
        // something.
        if (isUndefined(emoji)) {
          return false;
        }

        state.apply(emoji.emoji);

        return true;
      },

      /**
       * Clear suggestions when the escape key is pressed.
       */
      Escape: () => {
        if (!state) {
          return false;
        }

        // Ignore the current mention so that it doesn't show again for this
        // matching area
        helpers
          .getSuggestMethods()
          .addIgnored({ from: state.range.from, name: 'emoji', specific: true });

        setState(null);
        return true;
      },

      ArrowDown,
      ArrowUp,
    }),
    [ArrowDown, ArrowUp, state, helpers, setState],
  );

  useKeymap(bindings, ExtensionPriority.High);
}

type SetEmojiState = Dispatch<SetStateAction<EmojiState | null>>;

/**
 * This hook provides the state for setting up an emoji state change handler. It
 * applies the keybindings and the required change handlers.
 *
 *
 */
export function useEmoji(): EmojiState | null {
  const [state, setState] = useState<EmojiState | null>(null);

  useEmojiChangeHandler(setState);
  useEmojiKeyBindings(setState, state);

  return state;
}
